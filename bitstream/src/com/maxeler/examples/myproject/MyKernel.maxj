package com.maxeler.examples.dynamicgap;

import maxpower.kernel.lite.FrameIO;
import maxpower.kernel.lite.FrameIO.FrameInput;
import maxpower.kernel.lite.FrameIO.InterFrameGapSpec;
import maxpower.kernel.lite.LiteUtils;

import com.maxeler.examples.dynamicgap.Types.DynamicGapLinkType;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelLite;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelLite.IO.PushOutput;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.Reductions;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEStruct;
import com.maxeler.networking.v1.managers.NetworkManager;

public class Processor extends KernelLite {
	public static String INPUT = "inputFrame";
	public static String OUTPUT = "outputFrame";

	public Processor(NetworkManager owner) {
		super(owner, "processor");

		DynamicGapLinkType linkType = Types.dynamicGapLinkType;

		DFEVar requiredGap = dfeUInt(8).newInstance(this);

		FrameIO fio = new FrameIO(this);
		FrameInput<DFEStruct> input = fio.frameInput(INPUT, linkType, new InterFrameGapSpec(requiredGap));

		DFEStruct inputStruct = input.data;
		DFEVar inputValid = input.valid;
		DFEVar sof = (DFEVar)inputStruct.get(linkType.getSOF());
		DFEVar eof = (DFEVar)inputStruct.get(linkType.getEOF());
		DFEVar data = inputStruct.get(linkType.getData());

		LiteUtils lutils = new LiteUtils(this);
		DFEVar pipeStall = lutils.makeContiguousStall(INPUT, inputValid, eof);
		DFEVar globalCycle = control.count.makeCounter(control.count.makeParams(32)).getCount();

		pushStall(pipeStall);

		/*
		 * Based on the input frame, find out what the inter-frame-gap should be.
		 *
		 * Lets assume the 20th byte (0 base) of the packet is the MessageType.
		 * If MessageType = 'G' then insert a Gap of 100 cycles. Otherwise, Gap = 0.
		 */



		DFEVar isStart = sof & inputValid;
		DFEVar isEnd = eof & inputValid;
		// Get 20th byte
		DFEVar messageType = getByte(data, 20);
		requiredGap <== Reductions.streamHold(messageType === constant.var(dfeUInt(8), 'G') ? constant.var(dfeUInt(8), 100) : constant.var(dfeUInt(8), 0), isStart);




		DFEVar packetNumber = control.count.makeCounter(control.count.makeParams(16).withEnable(isEnd)).getCount();
		DFEVar packetIndex = control.count.makeCounter(control.count.makeParams(16).withReset(isStart).withEnable(inputValid)).getCount();



		DFEStruct outputData = linkType.newInstance(this);
		outputData <== inputStruct;

		DFEVar outputValid = inputValid.scheduleWith((DFEVar)outputData.get(linkType.getData()));

		DFEVar stalledCycleCount = control.count.makeCounter(control.count.makeParams(16).withReset(isStart)).getCount();
//		debug.simPrintf("[%d] Processor frame[%d]: [%d] sof %d, eof %d, data 0x%x\n",
//				packetNumber,
//				packetIndex,
//				inputStruct.get(linkType.getSOF()),
//				inputStruct.get(linkType.getEOF()),
//				inputStruct.get(linkType.getData()));
		debug.simPrintf("[%d] inputValid = %d, pipeStall = %d, stalledCycleCount = %d\n", globalCycle, inputValid, wire(pipeStall), stalledCycleCount);

		popStall();



		debug.simPrintf(inputValid, "Valid: %d\n", globalCycle);


		/*
		 * The input now will have a gap packet in between normal packets.
		 */



		PushOutput<DFEStruct> pushOut = io.pushOutput(OUTPUT, linkType, 8);

		pushOut.data <== outputData;
		pushOut.valid <== outputValid & ~pipeStall;

		input.stall <== optimization.pipeline(pushOut.stall);

	}

	public DFEVar getByte(DFEVar data, int offset) {
		int bytesPerWord = data.getType().getTotalBytes();

		int wordOffset = offset / bytesPerWord;
		int byteOffset = offset % bytesPerWord;

		// 8 bits in a byte...
		return stream.offset(data, wordOffset).slice(byteOffset * 8, 8).cast(dfeUInt(8));
	}

}
